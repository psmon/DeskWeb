<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <!-- Cache control - force reload on new deployment -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <!-- Setup the viewport for mobile and desktop environments -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0" />

  <!-- Configure linking of this application to the home screen of mobile devices -->
  <meta name="apple-mobile-web-app-title" content="deskweb"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <meta name="msapplication-tap-highlight" content="no"/>
  <link rel="apple-touch-icon" href="${resourcePath}deskweb/app.png"/>
  <link rel="icon" sizes="192x192" href="${resourcePath}deskweb/app.png">

  <!-- Disable chrome translation requests and automatic phone number linking -->
  <meta name="google" value="notranslate"/>
  <meta name="format-detection" content="telephone=no"/>

  <!-- Shortcut icon setup -->
  <link rel="shortcut icon" type="image/png" href="${resourcePath}deskweb/favicon.png"/>
  <link rel="mask-icon" href="${resourcePath}deskweb/favicon.png"/>

  <style>
    body {
      padding: 0px;
      margin: 0px;
      width: 100%;
      height: 100%;
      position: fixed;
      -webkit-touch-callout: none !important;
      overflow: hidden;
    }

    /* Markdown rendering styles - for both Label and Html widgets */
    .qx-label h1, .qx-label h2, .qx-label h3, .qx-label h4, .qx-label h5, .qx-label h6,
    .qx-html h1, .qx-html h2, .qx-html h3, .qx-html h4, .qx-html h5, .qx-html h6 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      font-weight: bold;
    }

    .qx-label h1, .qx-html h1 { font-size: 1.5em; }
    .qx-label h2, .qx-html h2 { font-size: 1.3em; }
    .qx-label h3, .qx-html h3 { font-size: 1.1em; }
    .qx-label h4, .qx-label h5, .qx-label h6,
    .qx-html h4, .qx-html h5, .qx-html h6 { font-size: 1em; }

    .qx-label p, .qx-html p {
      margin: 0.5em 0;
    }

    .qx-label pre, .qx-html pre {
      background-color: #f6f8fa;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 8px 12px;
      overflow-x: auto;
      margin: 0.5em 0;
    }

    .qx-label code, .qx-html code {
      background-color: #f6f8fa;
      border-radius: 3px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .qx-label pre code, .qx-html pre code {
      background-color: transparent;
      border: none;
      padding: 0;
    }

    .qx-label ul, .qx-label ol,
    .qx-html ul, .qx-html ol {
      margin: 0.5em 0;
      padding-left: 2em;
    }

    .qx-label li, .qx-html li {
      margin: 0.2em 0;
    }

    .qx-label blockquote, .qx-html blockquote {
      border-left: 4px solid #d0d7de;
      padding-left: 1em;
      margin: 0.5em 0;
      color: #57606a;
    }

    .qx-label table, .qx-html table {
      border-collapse: collapse;
      margin: 0.5em 0;
      width: 100%;
    }

    .qx-label th, .qx-label td,
    .qx-html th, .qx-html td {
      border: 1px solid #d0d7de;
      padding: 6px 13px;
    }

    .qx-label th, .qx-html th {
      background-color: #f6f8fa;
      font-weight: bold;
    }

    .qx-label a, .qx-html a {
      color: #0969da;
      text-decoration: none;
    }

    .qx-label a:hover, .qx-html a:hover {
      text-decoration: underline;
    }

    .qx-label hr, .qx-html hr {
      border: none;
      border-top: 1px solid #d0d7de;
      margin: 1em 0;
    }

    /* Mermaid diagram styles */
    .qx-label .mermaid, .qx-html .mermaid {
      background-color: white;
      padding: 10px;
      border-radius: 6px;
      margin: 0.5em 0;
      text-align: center;
    }

    /* Enable text selection in HTML widgets */
    .qx-html {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
  </style>

  <title>deskweb</title>
  <noscript>
    <meta http-equiv="refresh" content="0; url=nojs.html"/>
  </noscript>

  <!-- Markdown rendering libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>
  <script>
    // Initialize Mermaid
    if (typeof mermaid !== 'undefined') {
      mermaid.initialize({
        startOnLoad: false,
        theme: 'default',
        securityLevel: 'loose'
      });
    }
  </script>

  <!-- CFB Library for HWP parsing -->
  <script src="resource/deskweb/lib/cfb.js"></script>

  <!-- HWP Parser Implementation with CFB -->
  <script>
    // HWP viewer implementation with CFB library
    (function() {
      // Extract text from HWP using CFB library
      function extractText(data) {
        try {
          // Check if CFB library is loaded
          if (typeof CFB === 'undefined') {
            console.warn('[HWP] CFB library not loaded, using fallback');
            return extractTextFallback(data);
          }

          console.log('[HWP] Parsing HWP file with CFB library');

          // Parse HWP file using CFB
          var cfb = CFB.read(data, { type: 'array' });

          console.log('[HWP] CFB parsed successfully');
          console.log('[HWP] CFB FileIndex:', cfb.FileIndex ? cfb.FileIndex.length : 0);

          // Try to find PrvText stream
          var prvTextEntry = null;
          if (cfb.FileIndex) {
            for (var i = 0; i < cfb.FileIndex.length; i++) {
              var entry = cfb.FileIndex[i];
              console.log('[HWP] Entry:', entry.name, 'Type:', entry.type);
              if (entry.name === 'PrvText' || entry.name === '\u0005PrvText') {
                prvTextEntry = entry;
                console.log('[HWP] Found PrvText entry');
                break;
              }
            }
          }

          if (prvTextEntry && prvTextEntry.content) {
            console.log('[HWP] PrvText content size:', prvTextEntry.content.length);

            // PrvText is stored as UTF-16 LE (Little Endian)
            var prvTextData = prvTextEntry.content;
            var text = '';

            // Decode UTF-16 LE
            for (var i = 0; i < prvTextData.length - 1; i += 2) {
              var charCode = prvTextData[i] | (prvTextData[i + 1] << 8);
              if (charCode !== 0 && charCode !== 0xFEFF) { // Skip null and BOM
                text += String.fromCharCode(charCode);
              }
            }

            console.log('[HWP] Extracted text length:', text.length);
            console.log('[HWP] Text preview:', text.substring(0, 100));

            if (text.length > 0) {
              return text;
            }
          }

          // If PrvText not found or empty, try fallback
          console.warn('[HWP] PrvText not found or empty, using fallback');
          return extractTextFallback(data);

        } catch (e) {
          console.error('[HWP] CFB parsing error:', e);
          return extractTextFallback(data);
        }
      }

      // Fallback text extraction (original method)
      function extractTextFallback(data) {
        var text = '';
        var decoder = new TextDecoder('utf-8', { fatal: false });

        try {
          text = decoder.decode(data);
          text = text.replace(/[\x00-\x1F\x7F-\x9F]/g, ' ');

          var koreanText = text.match(/[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]+/g);
          if (koreanText && koreanText.length > 0) {
            return koreanText.join(' ');
          }

          var asciiText = text.match(/[a-zA-Z0-9\s.,!?;:'"()-]{10,}/g);
          if (asciiText && asciiText.length > 0) {
            return asciiText.join(' ');
          }

          return null;
        } catch (e) {
          console.error('[HWP] Fallback text extraction error:', e);
          return null;
        }
      }

      function formatText(text) {
        if (!text || text.length === 0) {
          return '<p style="color: #999;">텍스트를 추출할 수 없습니다.</p>';
        }

        // Escape HTML
        text = text.replace(/&/g, '&amp;')
                   .replace(/</g, '&lt;')
                   .replace(/>/g, '&gt;');

        // Split by line breaks (both \n and \r\n)
        var lines = text.split(/\r?\n/);
        var html = '';

        lines.forEach(function(line) {
          line = line.trim();
          if (line.length > 0) {
            html += '<p style="margin: 8px 0; color: #333; line-height: 1.8; font-family: \'Malgun Gothic\', \'맑은 고딕\', sans-serif;">' + line + '</p>';
          } else {
            // Empty line = paragraph break
            html += '<div style="height: 8px;"></div>';
          }
        });

        return html || '<p style="color: #999;">텍스트 형식을 인식할 수 없습니다.</p>';
      }

      function getFileSignature(data) {
        if (!data || data.length < 4) return 'N/A';
        var sig = '';
        for (var i = 0; i < Math.min(4, data.length); i++) {
          sig += ('0' + data[i].toString(16)).slice(-2).toUpperCase() + ' ';
        }
        return sig.trim();
      }

      function getHexDump(data, maxBytes) {
        var bytes = Math.min(maxBytes || 256, data.length);
        var result = '';

        for (var i = 0; i < bytes; i += 16) {
          result += ('0000' + i.toString(16)).slice(-4).toUpperCase() + '  ';

          for (var j = 0; j < 16; j++) {
            if (i + j < bytes) {
              result += ('0' + data[i + j].toString(16)).slice(-2).toUpperCase() + ' ';
            } else {
              result += '   ';
            }
            if (j === 7) result += ' ';
          }

          result += ' ';

          for (var j = 0; j < 16; j++) {
            if (i + j < bytes) {
              var byte = data[i + j];
              result += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }
          }

          result += '\n';
        }

        return result;
      }

      function showFileStructure(data) {
        var signature = getFileSignature(data);
        var isHWP = signature.includes('D0 CF 11 E0');

        // Try to get CFB structure info
        var cfbInfo = '';
        try {
          if (typeof CFB !== 'undefined') {
            var cfb = CFB.read(data, { type: 'array' });
            if (cfb.FileIndex) {
              cfbInfo = '<div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-left: 3px solid #ffc107;">';
              cfbInfo += '<p style="margin: 0 0 10px 0; color: #856404; font-size: 14px;"><strong>CFB 스트림 목록:</strong></p>';
              cfbInfo += '<ul style="margin: 0; padding-left: 20px; color: #856404;">';
              for (var i = 0; i < Math.min(cfb.FileIndex.length, 10); i++) {
                var entry = cfb.FileIndex[i];
                if (entry.type !== 0) { // Not empty
                  cfbInfo += '<li>' + entry.name + ' (' + (entry.type === 2 ? 'File' : 'Directory') + ')</li>';
                }
              }
              if (cfb.FileIndex.length > 10) {
                cfbInfo += '<li>... and ' + (cfb.FileIndex.length - 10) + ' more</li>';
              }
              cfbInfo += '</ul></div>';
            }
          }
        } catch (e) {
          console.error('[HWP] Error getting CFB structure:', e);
        }

        return `
          <div style="background: #f8f9fa; padding: 20px; border-radius: 4px;">
            <h4 style="color: #0078d4; margin-top: 0;">파일 구조 정보</h4>
            <p style="color: #555;"><strong>파일 시그니처:</strong> ${signature}</p>
            <p style="color: #555;"><strong>파일 형식:</strong> ${isHWP ? 'HWP (OLE2 복합 문서)' : '알 수 없음'}</p>
            <p style="color: #555;"><strong>데이터 크기:</strong> ${data.length} bytes (${Math.round(data.length / 1024)} KB)</p>

            <div style="margin-top: 20px; padding: 15px; background: white; border: 1px solid #ddd;">
              <p style="margin: 0; color: #666; line-height: 1.6;">
                이 HWP 파일은 복합 문서 형식입니다.
                PrvText 스트림에서 미리보기 텍스트를 추출하지 못했습니다.
                완전한 문서를 보려면 BodyText 섹션 파싱이 필요합니다.
              </p>
            </div>

            ${cfbInfo}

            <div style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-left: 3px solid #2196f3;">
              <p style="margin: 0; color: #1976d2; font-size: 14px;">
                <strong>원시 데이터 미리보기:</strong>
              </p>
              <pre style="margin: 10px 0 0 0; padding: 10px; background: white; border: 1px solid #ddd; overflow-x: auto; font-size: 12px;">${getHexDump(data, 256)}</pre>
            </div>
          </div>
        `;
      }

      // Main Viewer constructor
      window.hwpjs = {
        Viewer: function(container, data) {
          console.log('[HWP] Simple HWP Viewer initialized');
          console.log('[HWP] Data size:', data ? data.length : 0);

          if (!data || data.length === 0) {
            container.innerHTML = '<p style="color: red;">No data provided</p>';
            return this;
          }

          try {
            var text = extractText(data);

            container.innerHTML = `
            <div style="background: white; padding: 40px; max-width: 800px; margin: 0 auto; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <div style="background: #0078d4; color: white; padding: 15px; margin: -40px -40px 20px -40px;">
                <h2 style="margin: 0; font-size: 18px;">한글 문서 (HWP)</h2>
              </div>
              <div style="background: #f8f9fa; padding: 20px; border-left: 4px solid #0078d4; margin-bottom: 20px;">
                <p style="margin: 0; color: #333;"><strong>파일 크기:</strong> ${Math.round(data.length / 1024)} KB</p>
                <p style="margin: 5px 0 0 0; color: #333;"><strong>데이터:</strong> ${data.length} bytes</p>
              </div>
              <div style="background: white; padding: 30px; border: 1px solid #ddd; min-height: 400px; line-height: 1.8;">
                <h3 style="color: #0078d4; margin-top: 0;">문서 내용</h3>
                ${text ? formatText(text) : showFileStructure(data)}
              </div>
              <div style="background: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; margin-top: 20px;">
                <p style="margin: 0; color: #856404; font-size: 14px;">
                  <strong>참고:</strong> 이것은 기본적인 HWP 파일 뷰어입니다.
                  완전한 렌더링을 위해서는 추가 라이브러리가 필요합니다.
                </p>
              </div>
            </div>
          `;
        } catch (error) {
          console.error('[HWP] Error parsing file:', error);
          container.innerHTML = `
            <div style="padding: 40px;">
              <h3 style="color: #d32f2f;">HWP 파일 분석 오류</h3>
              <p style="color: #666;">오류: ${error.message}</p>
              <div style="background: #f5f5f5; padding: 20px; margin-top: 20px;">
                <p><strong>파일 정보:</strong></p>
                <ul>
                  <li>크기: ${Math.round(data.length / 1024)} KB</li>
                  <li>바이트: ${data.length}</li>
                  <li>첫 4바이트: ${getFileSignature(data)}</li>
                </ul>
              </div>
            </div>
          `;
        }

        return this;
      }
    };

    console.log('[HWP] Simple HWP viewer loaded');
    })();

  </script>

  <!-- HWP.js fallback placeholder -->
  <script>
    // Fallback placeholder if CDN load fails
    if (typeof window.hwpjs === 'undefined') {
      window.hwpjs = {
        Viewer: function(container, data) {
          console.log('[HWP] Fallback Placeholder Viewer initialized');
          console.log('[HWP] Container:', container);
          console.log('[HWP] Data size:', data ? data.length : 0);

          // Create a placeholder UI with scrollable content
          container.innerHTML = `
          <div style="padding: 40px; background: white; border: 2px dashed #ccc; border-radius: 8px; text-align: center; min-height: 1200px;">
            <h2 style="color: #0078d4; margin-bottom: 20px;">HWP 뷰어</h2>
            <div style="background: #f0f0f0; padding: 30px; border-radius: 6px; margin: 20px 0;">
              <p style="font-size: 16px; color: #333; margin: 10px 0;">
                <strong>파일 정보:</strong>
              </p>
              <p style="color: #666; margin: 5px 0;">
                파일 크기: ${data ? Math.round(data.length / 1024) + ' KB' : '알 수 없음'}
              </p>
              <p style="color: #666; margin: 5px 0;">
                형식: HWP (한글 워드프로세서)
              </p>
            </div>
            <div style="background: #e8f4f8; padding: 20px; border-left: 4px solid #0078d4; margin: 20px 0; text-align: left;">
              <p style="margin: 5px 0; color: #333;"><strong>안내:</strong></p>
              <p style="margin: 5px 0; color: #555;">HWP 파일이 성공적으로 로드되었습니다.</p>
              <p style="margin: 5px 0; color: #555;">실제 HWP 문서 렌더링을 위해서는 hwp.js 브라우저 번들이 필요합니다.</p>
            </div>
            <div style="margin-top: 30px; padding: 20px; background: white; border: 1px solid #ddd; text-align: left;">
              <h3 style="color: #0078d4; margin-bottom: 15px;">구현된 기능:</h3>
              <ul style="color: #555; line-height: 1.8; list-style-position: inside;">
                <li>✅ HWP 파일 열기 (파일 선택 대화상자)</li>
                <li>✅ 가상 파일 시스템에서 HWP 파일 로드</li>
                <li>✅ 확대/축소 기능</li>
                <li>✅ 페이지 탐색 기능</li>
                <li>✅ 인쇄 기능</li>
                <li>✅ 드래그 앤 드롭 지원</li>
                <li>✅ 스크롤 기능</li>
                <li>⏳ HWP 문서 렌더링 (hwp.js 브라우저 번들 필요)</li>
              </ul>
            </div>
            <div style="margin-top: 30px; padding: 30px; background: #f9f9f9; border: 1px solid #ddd; text-align: left;">
              <h3 style="color: #0078d4; margin-bottom: 15px;">문서 내용 미리보기</h3>
              <p style="color: #555; line-height: 1.8; margin: 10px 0;">
                이곳에는 실제 HWP 문서의 내용이 표시됩니다.
              </p>
              <p style="color: #555; line-height: 1.8; margin: 10px 0;">
                hwp.js 라이브러리가 통합되면 한글 워드프로세서 문서의 텍스트, 이미지, 표,
                그리고 다양한 서식이 원본 그대로 렌더링됩니다.
              </p>
              <div style="background: white; padding: 20px; margin: 20px 0; border-left: 3px solid #0078d4;">
                <h4 style="color: #333; margin: 10px 0;">스크롤 테스트 영역</h4>
                <p style="color: #666; line-height: 1.6;">
                  이 영역은 스크롤 기능을 테스트하기 위한 공간입니다.
                  창의 크기를 조절하거나 확대/축소 기능을 사용하여
                  스크롤바가 정상적으로 작동하는지 확인하실 수 있습니다.
                </p>
                ${Array(10).fill(0).map((_, i) => `
                  <p style="color: #888; line-height: 1.6; margin: 10px 0;">
                    ${i + 1}. 스크롤 테스트 라인입니다.
                    이 텍스트는 스크롤 기능이 정상적으로 작동하는지 확인하기 위한 것입니다.
                    창의 높이보다 컨텐츠가 길 경우 스크롤바가 나타나야 합니다.
                  </p>
                `).join('')}
              </div>
            </div>
            <div style="margin-top: 30px; padding: 20px; background: #fff3cd; border-left: 4px solid #ffc107; text-align: left;">
              <h4 style="color: #856404; margin: 10px 0;">향후 개선 사항</h4>
              <ul style="color: #856404; line-height: 1.8;">
                <li>실제 HWP 문서 렌더링</li>
                <li>텍스트 검색 기능</li>
                <li>북마크 기능</li>
                <li>주석 추가 기능</li>
                <li>PDF 변환 기능</li>
              </ul>
            </div>
          </div>
        `;

          return this;
        }
      };

      console.log('[HWP] Fallback placeholder initialized');
    }
  </script>

  ${preBootJs}

  <!-- Service Worker Registration for cache management -->
  <script>
    // Register Service Worker for cache busting
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('${resourcePath}deskweb/sw.js?v=' + Date.now())
          .then(function(registration) {
            console.log('[App] ServiceWorker registered:', registration.scope);

            // Check for updates every 60 seconds
            setInterval(function() {
              registration.update();
            }, 60000);

            // Listen for updates
            registration.addEventListener('updatefound', function() {
              const newWorker = registration.installing;
              console.log('[App] ServiceWorker update found');

              newWorker.addEventListener('statechange', function() {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  console.log('[App] New ServiceWorker installed, reloading page...');

                  // Notify user and reload
                  if (confirm('A new version is available. Reload to update?')) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch(function(error) {
            console.log('[App] ServiceWorker registration failed:', error);
          });

        // Handle controller change (new service worker activated)
        navigator.serviceWorker.addEventListener('controllerchange', function() {
          console.log('[App] ServiceWorker controller changed, reloading...');
          window.location.reload();
        });
      });
    }

    // Add timestamp to prevent cache
    (function() {
      var timestamp = new Date().getTime();
      console.log('[App] Loading with timestamp:', timestamp);

      // Store version info
      window.DESKWEB_VERSION = timestamp;
    })();
  </script>

  <script type="text/javascript" src="${appPath}index.js?v=${timestamp}"></script>

 </head>
<body>
</body>
</html>
