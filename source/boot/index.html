<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />

  <!-- Cache control - force reload on new deployment -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <!-- Setup the viewport for mobile and desktop environments -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=0, minimum-scale=1.0, maximum-scale=1.0" />

  <!-- Configure linking of this application to the home screen of mobile devices -->
  <meta name="apple-mobile-web-app-title" content="deskweb"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
  <meta name="msapplication-tap-highlight" content="no"/>
  <link rel="apple-touch-icon" href="${resourcePath}deskweb/app.png"/>
  <link rel="icon" sizes="192x192" href="${resourcePath}deskweb/app.png">

  <!-- Disable chrome translation requests and automatic phone number linking -->
  <meta name="google" value="notranslate"/>
  <meta name="format-detection" content="telephone=no"/>

  <!-- Shortcut icon setup -->
  <link rel="shortcut icon" type="image/png" href="${resourcePath}deskweb/favicon.png"/>
  <link rel="mask-icon" href="${resourcePath}deskweb/favicon.png"/>

  <style>
    body {
      padding: 0px;
      margin: 0px;
      width: 100%;
      height: 100%;
      position: fixed;
      -webkit-touch-callout: none !important;
      overflow: hidden;
    }

    /* Markdown rendering styles - for both Label and Html widgets */
    .qx-label h1, .qx-label h2, .qx-label h3, .qx-label h4, .qx-label h5, .qx-label h6,
    .qx-html h1, .qx-html h2, .qx-html h3, .qx-html h4, .qx-html h5, .qx-html h6 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
      font-weight: bold;
    }

    .qx-label h1, .qx-html h1 { font-size: 1.5em; }
    .qx-label h2, .qx-html h2 { font-size: 1.3em; }
    .qx-label h3, .qx-html h3 { font-size: 1.1em; }
    .qx-label h4, .qx-label h5, .qx-label h6,
    .qx-html h4, .qx-html h5, .qx-html h6 { font-size: 1em; }

    .qx-label p, .qx-html p {
      margin: 0.5em 0;
    }

    .qx-label pre, .qx-html pre {
      background-color: #f6f8fa;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      padding: 8px 12px;
      overflow-x: auto;
      margin: 0.5em 0;
    }

    .qx-label code, .qx-html code {
      background-color: #f6f8fa;
      border-radius: 3px;
      padding: 2px 6px;
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
    }

    .qx-label pre code, .qx-html pre code {
      background-color: transparent;
      border: none;
      padding: 0;
    }

    .qx-label ul, .qx-label ol,
    .qx-html ul, .qx-html ol {
      margin: 0.5em 0;
      padding-left: 2em;
    }

    .qx-label li, .qx-html li {
      margin: 0.2em 0;
    }

    .qx-label blockquote, .qx-html blockquote {
      border-left: 4px solid #d0d7de;
      padding-left: 1em;
      margin: 0.5em 0;
      color: #57606a;
    }

    .qx-label table, .qx-html table {
      border-collapse: collapse;
      margin: 0.5em 0;
      width: 100%;
    }

    .qx-label th, .qx-label td,
    .qx-html th, .qx-html td {
      border: 1px solid #d0d7de;
      padding: 6px 13px;
    }

    .qx-label th, .qx-html th {
      background-color: #f6f8fa;
      font-weight: bold;
    }

    .qx-label a, .qx-html a {
      color: #0969da;
      text-decoration: none;
    }

    .qx-label a:hover, .qx-html a:hover {
      text-decoration: underline;
    }

    .qx-label hr, .qx-html hr {
      border: none;
      border-top: 1px solid #d0d7de;
      margin: 1em 0;
    }

    /* Mermaid diagram styles */
    .qx-label .mermaid, .qx-html .mermaid {
      background-color: white;
      padding: 10px;
      border-radius: 6px;
      margin: 0.5em 0;
      text-align: center;
    }

    /* Enable text selection in HTML widgets */
    .qx-html {
      user-select: text;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
    }
  </style>

  <title>deskweb</title>
  <noscript>
    <meta http-equiv="refresh" content="0; url=nojs.html"/>
  </noscript>

  <!-- Markdown rendering libraries -->
  <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/lib/marked.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10.6.1/dist/mermaid.min.js"></script>

  <!-- Three.js for 3D Tetris -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/renderers/CSS3DRenderer.js"></script>

  <!-- SheetJS for Calc spreadsheet ODS/XLSX support -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
  <script>
    // Initialize Mermaid
    if (typeof mermaid !== 'undefined') {
      mermaid.initialize({
        startOnLoad: false,
        theme: 'default',
        securityLevel: 'loose'
      });
    }
  </script>

  <!-- CFB Library for HWP parsing -->
  <script src="resource/deskweb/lib/cfb.js"></script>
  <!-- Pako Library for zlib decompression -->
  <script src="resource/deskweb/lib/pako_inflate.min.js"></script>

  <!-- HWP Parser Implementation with CFB -->
  <script>
    // HWP viewer implementation with CFB library
    (function() {
      // Extract text with detailed information (preview + full text)
      function extractTextWithDetails(data) {
        try {
          // Check if CFB library is loaded
          if (typeof CFB === 'undefined') {
            console.warn('[HWP] CFB library not loaded, using fallback');
            return {
              preview: extractTextFallback(data),
              fullText: null,
              sections: [],
              pageCount: 0,
              source: 'fallback'
            };
          }

          console.log('[HWP] Parsing HWP file with CFB library');

          // Parse HWP file using CFB
          var cfb = CFB.read(data, { type: 'array' });

          console.log('[HWP] CFB parsed successfully');
          console.log('[HWP] CFB FileIndex:', cfb.FileIndex ? cfb.FileIndex.length : 0);

          // Extract both preview and full text
          var prvTextExtracted = extractPrvText(cfb);
          var bodyTextData = extractBodyTextWithSections(cfb);

          // Determine which source to use
          var result = {
            preview: prvTextExtracted,
            fullText: bodyTextData.text,
            sections: bodyTextData.sections,
            pageCount: bodyTextData.sections.length || 0,
            source: 'none'
          };

          if (bodyTextData.text && bodyTextData.text.length > 0) {
            result.source = 'bodytext';
            console.log('[HWP] Using BodyText, sections:', result.sections.length);
          } else if (prvTextExtracted && prvTextExtracted.length > 0) {
            result.source = 'prvtext';
            result.pageCount = 1; // Preview is typically 1-2 pages
            console.log('[HWP] Using PrvText only');
          } else {
            result.source = 'fallback';
            result.preview = extractTextFallback(data);
            console.warn('[HWP] Using fallback method');
          }

          return result;

        } catch (e) {
          console.error('[HWP] CFB parsing error:', e);
          return {
            preview: extractTextFallback(data),
            fullText: null,
            sections: [],
            pageCount: 0,
            source: 'fallback'
          };
        }
      }

      // Extract text from HWP using CFB library (backward compatibility)
      function extractText(data) {
        var textData = extractTextWithDetails(data);
        return textData.fullText || textData.preview || '';
      }

      // Extract text from PrvText stream (preview, 1-2 pages)
      function extractPrvText(cfb) {
        try {
          var prvTextEntry = null;
          if (cfb.FileIndex) {
            for (var i = 0; i < cfb.FileIndex.length; i++) {
              var entry = cfb.FileIndex[i];
              if (entry.name === 'PrvText' || entry.name === '\u0005PrvText') {
                prvTextEntry = entry;
                console.log('[HWP] Found PrvText entry');
                break;
              }
            }
          }

          if (prvTextEntry && prvTextEntry.content) {
            console.log('[HWP] PrvText content size:', prvTextEntry.content.length);

            // PrvText is stored as UTF-16 LE (Little Endian)
            var prvTextData = prvTextEntry.content;
            var text = '';

            // Decode UTF-16 LE
            for (var i = 0; i < prvTextData.length - 1; i += 2) {
              var charCode = prvTextData[i] | (prvTextData[i + 1] << 8);
              if (charCode !== 0 && charCode !== 0xFEFF) { // Skip null and BOM
                text += String.fromCharCode(charCode);
              }
            }

            console.log('[HWP] PrvText extracted, length:', text.length);
            return text;
          }
          return null;
        } catch (e) {
          console.error('[HWP] PrvText extraction error:', e);
          return null;
        }
      }

      // Extract text from BodyText sections with section details (full content)
      function extractBodyTextWithSections(cfb) {
        try {
          if (!cfb.FileIndex) return { text: null, sections: [] };

          // Log all entries to see the structure
          console.log('[HWP] === All CFB Entries ===');
          for (var i = 0; i < cfb.FileIndex.length; i++) {
            var entry = cfb.FileIndex[i];
            if (entry.type !== 0) { // Skip empty entries
              console.log('[HWP] Entry[' + i + ']:', entry.name, 'Type:', entry.type, 'Size:', entry.size);
            }
          }
          console.log('[HWP] === End of CFB Entries ===');

          var bodyTextSections = [];

          // Find all BodyText sections with flexible matching
          for (var i = 0; i < cfb.FileIndex.length; i++) {
            var entry = cfb.FileIndex[i];
            if (!entry.name) continue;

            // Match various patterns: BodyText/Section*, Section*, BodyText*
            var name = entry.name.toLowerCase();
            if (name.indexOf('bodytext') !== -1 || name.indexOf('section') !== -1) {
              if (entry.type === 2 && entry.size > 0) { // Type 2 = file, not directory
                bodyTextSections.push(entry);
                console.log('[HWP] Found potential BodyText section:', entry.name, 'Size:', entry.size);
              }
            }
          }

          if (bodyTextSections.length === 0) {
            console.warn('[HWP] No BodyText sections found');
            return { text: null, sections: [] };
          }

          var sections = [];

          // Process each section
          for (var i = 0; i < bodyTextSections.length; i++) {
            var section = bodyTextSections[i];
            if (!section.content) continue;

            try {
              // BodyText sections might be compressed with zlib
              var decompressed = null;

              // Try decompression first if pako is available
              if (typeof pako !== 'undefined' && pako.inflate) {
                console.log('[HWP] Pako available, attempting decompression of', section.name);
                console.log('[HWP] Section content type:', section.content.constructor.name);
                console.log('[HWP] Section first 16 bytes:', Array.from(section.content.slice(0, 16)).map(function(b) {
                  return ('0' + b.toString(16)).slice(-2);
                }).join(' '));

                try {
                  // Try inflate with different options
                  decompressed = pako.inflate(section.content);
                  console.log('[HWP] Successfully decompressed section', section.name, 'size:', decompressed.length);
                } catch (inflateError) {
                  console.error('[HWP] Pako inflate failed for', section.name);
                  console.error('[HWP] Error:', inflateError);
                  console.error('[HWP] Error message:', inflateError.message);
                  console.error('[HWP] Error stack:', inflateError.stack);

                  // Try inflateRaw (without zlib header)
                  try {
                    console.log('[HWP] Trying inflateRaw...');
                    decompressed = pako.inflateRaw(section.content);
                    console.log('[HWP] Successfully decompressed with inflateRaw', section.name, 'size:', decompressed.length);
                  } catch (rawError) {
                    console.error('[HWP] inflateRaw also failed:', rawError.message);
                    // Last resort: use uncompressed
                    console.warn('[HWP] Using uncompressed section data');
                    decompressed = section.content;
                  }
                }
              } else {
                console.error('[HWP] Pako library not available! typeof pako:', typeof pako);
                decompressed = section.content;
              }

              if (decompressed) {
                // Extract text from decompressed data
                var sectionText = extractTextFromBodySection(decompressed);
                if (sectionText && sectionText.trim().length > 0) {
                  sections.push({
                    name: section.name,
                    pageNumber: i + 1,
                    text: sectionText
                  });
                }
              }
            } catch (sectionError) {
              console.error('[HWP] Error processing section', section.name, ':', sectionError);
            }
          }

          // Combine all sections
          var allText = sections.map(function(s) { return s.text; }).join('\n\n');

          return { text: allText, sections: sections };
        } catch (e) {
          console.error('[HWP] BodyText extraction error:', e);
          return { text: null, sections: [] };
        }
      }

      // Extract text from BodyText sections (backward compatibility)
      function extractBodyText(cfb) {
        var result = extractBodyTextWithSections(cfb);
        return result.text;
      }

      // Extract text from decompressed BodyText section data
      function extractTextFromBodySection(data) {
        try {
          var text = '';
          var i = 0;
          var recordCount = 0;
          var textRecordCount = 0;
          var HWPTAG_BEGIN = 0x010;
          var HWPTAG_PARA_HEADER = HWPTAG_BEGIN + 50;  // 0x042
          var HWPTAG_PARA_TEXT = HWPTAG_BEGIN + 51;    // 0x043

          console.log('[HWP] === Parsing Section Data (HWP 5.0 Spec) ===');
          console.log('[HWP] Section data length:', data.length);
          console.log('[HWP] First 32 bytes:', Array.from(data.slice(0, 32)).map(function(b) {
            return ('0' + b.toString(16)).slice(-2);
          }).join(' '));

          // HWP 5.0 Record Structure:
          // Header: 4 bytes with bit fields
          //   - Tag ID: bits 0-9 (10 bits)
          //   - Level: bits 10-19 (10 bits)
          //   - Size: bits 20-31 (12 bits, max 4095 bytes)
          // Data: Size bytes
          // Alignment: Records are 4-byte aligned

          while (i < data.length - 4) {
            // Read 4-byte header
            var header = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24);

            // Extract bit fields according to HWP 5.0 spec
            var tag = header & 0x3FF;              // Bits 0-9: Tag ID
            var level = (header >> 10) & 0x3FF;    // Bits 10-19: Level
            var size = (header >> 20) & 0xFFF;     // Bits 20-31: Size (12 bits, max 4095)

            recordCount++;
            i += 4;  // Move past header

            if (recordCount <= 15) {
              console.log('[HWP] Record', recordCount, '@ offset', (i - 4), '- Tag: 0x' + tag.toString(16).padStart(3, '0'),
                         'Level:', level, 'Size:', size);
            }

            // Handle extended size (if size == 4095, next DWORD contains actual size)
            var actualSize = size;
            if (size === 0xFFF && i + 4 <= data.length) {
              actualSize = data[i] | (data[i + 1] << 8) | (data[i + 2] << 16) | (data[i + 3] << 24);
              i += 4;
              if (recordCount <= 15) {
                console.log('[HWP]   Extended size detected: actual size =', actualSize);
              }
            }

            // Check bounds
            if (i + actualSize > data.length) {
              console.warn('[HWP] Record size exceeds data length, stopping parse');
              break;
            }

            if (recordCount <= 15 && actualSize > 0) {
              // Show first 32 bytes of record data
              var dataBytes = Array.from(data.slice(i, i + Math.min(32, actualSize))).map(function(b) {
                return ('0' + b.toString(16)).slice(-2);
              }).join(' ');
              console.log('[HWP]   Data preview (32 bytes):', dataBytes);
            }

            // Records are aligned to 4-byte boundaries
            var alignedSize = Math.ceil(actualSize / 4) * 4;

            if (recordCount <= 15) {
              // Show bytes at the end of this record (next record should start here)
              var nextRecordPos = i + alignedSize;
              var nextRecordBytes = Array.from(data.slice(nextRecordPos, nextRecordPos + 8)).map(function(b) {
                return ('0' + b.toString(16)).slice(-2);
              }).join(' ');
              console.log('[HWP]   Aligned size:', alignedSize, 'â†’ Next @ offset', nextRecordPos, ':', nextRecordBytes);
            }

            if (alignedSize < 0 || alignedSize > data.length - i) {
              console.warn('[HWP] Invalid record size at record', recordCount, '- size:', actualSize, 'remaining:', (data.length - i));
              break; // Invalid record
            }

            // HWPTAG_PARA_TEXT = 0x043 (paragraph text)
            if (tag === HWPTAG_PARA_TEXT) {
              textRecordCount++;
              if (textRecordCount <= 10) {
                console.log('[HWP] Found HWPTAG_PARA_TEXT #' + textRecordCount + ' at offset', (i - 4), 'size:', actualSize);
              }

              // Text is stored as UTF-16 LE
              var textData = data.slice(i, i + actualSize);

              if (textRecordCount <= 10 && actualSize > 0) {
                console.log('[HWP] Text data first 32 bytes:', Array.from(textData.slice(0, Math.min(32, actualSize))).map(function(b) {
                  return ('0' + b.toString(16)).slice(-2);
                }).join(' '));
              }

              var extractedText = '';
              for (var j = 0; j < textData.length - 1; j += 2) {
                var charCode = textData[j] | (textData[j + 1] << 8);
                // Filter out control characters but keep newlines and other whitespace
                if (charCode === 0x000A || charCode === 0x000D) {
                  extractedText += '\n';
                } else if (charCode > 0x001F && charCode !== 0xFEFF) {
                  extractedText += String.fromCharCode(charCode);
                }
              }

              if (textRecordCount <= 10 && extractedText.length > 0) {
                console.log('[HWP] Extracted text:', extractedText.substring(0, 100) + (extractedText.length > 100 ? '...' : ''));
              }
              text += extractedText;
            }

            // Use aligned size to move to next record
            i += alignedSize;
          }

          console.log('[HWP] Total records parsed:', recordCount);
          console.log('[HWP] Text records found:', textRecordCount);
          console.log('[HWP] Total text length:', text.length);
          console.log('[HWP] === End Section Parsing ===');

          return text;
        } catch (e) {
          console.error('[HWP] Error extracting text from section:', e);
          return null;
        }
      }

      // Fallback text extraction (original method)
      function extractTextFallback(data) {
        var text = '';
        var decoder = new TextDecoder('utf-8', { fatal: false });

        try {
          text = decoder.decode(data);
          text = text.replace(/[\x00-\x1F\x7F-\x9F]/g, ' ');

          var koreanText = text.match(/[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]+/g);
          if (koreanText && koreanText.length > 0) {
            return koreanText.join(' ');
          }

          var asciiText = text.match(/[a-zA-Z0-9\s.,!?;:'"()-]{10,}/g);
          if (asciiText && asciiText.length > 0) {
            return asciiText.join(' ');
          }

          return null;
        } catch (e) {
          console.error('[HWP] Fallback text extraction error:', e);
          return null;
        }
      }

      // Format complete document content with preview and full text
      function formatDocumentContent(textData, rawData) {
        if (!textData) {
          return showFileStructure(rawData);
        }

        var html = '';

        // Show preview section if available
        if (textData.preview && textData.preview.length > 0) {
          html += '<div style="background: white; padding: 30px; border: 2px solid #0078d4; margin-bottom: 20px; border-radius: 4px;">';
          html += '<div style="background: #0078d4; color: white; padding: 10px; margin: -30px -30px 20px -30px; border-radius: 4px 4px 0 0;">';
          html += '<h3 style="margin: 0; font-size: 16px;">ğŸ“„ ë¬¸ì„œ ë¯¸ë¦¬ë³´ê¸° (PrvText)</h3>';
          html += '</div>';
          html += formatText(textData.preview);
          html += '</div>';
        }

        // Show full text sections if available
        if (textData.sections && textData.sections.length > 0) {
          html += '<div style="background: white; padding: 30px; border: 2px solid #2196f3; border-radius: 4px;">';
          html += '<div style="background: #2196f3; color: white; padding: 10px; margin: -30px -30px 20px -30px; border-radius: 4px 4px 0 0;">';
          html += '<h3 style="margin: 0; font-size: 16px;">ğŸ“– ë³¸ë¬¸ ë‚´ìš© (BodyText)</h3>';
          html += '</div>';

          // Render each section as a page
          for (var i = 0; i < textData.sections.length; i++) {
            var section = textData.sections[i];
            html += '<div style="background: #fafafa; padding: 30px; margin-bottom: 20px; border: 1px solid #ddd; border-radius: 4px; position: relative; min-height: 400px;">';

            // Page number badge
            html += '<div style="position: absolute; top: 10px; right: 10px; background: #2196f3; color: white; padding: 5px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">';
            html += 'Page ' + section.pageNumber;
            html += '</div>';

            // Section content
            html += '<div style="margin-top: 30px;">';
            html += formatText(section.text);
            html += '</div>';

            // Page footer
            html += '<div style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ddd; color: #999; font-size: 12px;">';
            html += '- ' + section.pageNumber + ' / ' + textData.sections.length + ' -';
            html += '</div>';

            html += '</div>';
          }

          html += '</div>';
        } else if (textData.fullText && textData.fullText.length > 0) {
          // Fallback: show full text without section separation
          html += '<div style="background: white; padding: 30px; border: 1px solid #ddd; min-height: 400px; line-height: 1.8;">';
          html += '<h3 style="color: #2196f3; margin-top: 0;">ğŸ“– ë¬¸ì„œ ë‚´ìš©</h3>';
          html += formatText(textData.fullText);
          html += '</div>';
        } else if (!textData.preview || textData.preview.length === 0) {
          // No text extracted at all
          html += showFileStructure(rawData);
        }

        return html;
      }

      function formatText(text) {
        if (!text || text.length === 0) {
          return '<p style="color: #999;">í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
        }

        // Escape HTML
        text = text.replace(/&/g, '&amp;')
                   .replace(/</g, '&lt;')
                   .replace(/>/g, '&gt;');

        // Split by line breaks (both \n and \r\n)
        var lines = text.split(/\r?\n/);
        var html = '';

        lines.forEach(function(line) {
          line = line.trim();
          if (line.length > 0) {
            html += '<p style="margin: 8px 0; color: #333; line-height: 1.8; font-family: \'Malgun Gothic\', \'ë§‘ì€ ê³ ë”•\', sans-serif;">' + line + '</p>';
          } else {
            // Empty line = paragraph break
            html += '<div style="height: 8px;"></div>';
          }
        });

        return html || '<p style="color: #999;">í…ìŠ¤íŠ¸ í˜•ì‹ì„ ì¸ì‹í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>';
      }

      function getFileSignature(data) {
        if (!data || data.length < 4) return 'N/A';
        var sig = '';
        for (var i = 0; i < Math.min(4, data.length); i++) {
          sig += ('0' + data[i].toString(16)).slice(-2).toUpperCase() + ' ';
        }
        return sig.trim();
      }

      function getHexDump(data, maxBytes) {
        var bytes = Math.min(maxBytes || 256, data.length);
        var result = '';

        for (var i = 0; i < bytes; i += 16) {
          result += ('0000' + i.toString(16)).slice(-4).toUpperCase() + '  ';

          for (var j = 0; j < 16; j++) {
            if (i + j < bytes) {
              result += ('0' + data[i + j].toString(16)).slice(-2).toUpperCase() + ' ';
            } else {
              result += '   ';
            }
            if (j === 7) result += ' ';
          }

          result += ' ';

          for (var j = 0; j < 16; j++) {
            if (i + j < bytes) {
              var byte = data[i + j];
              result += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
            }
          }

          result += '\n';
        }

        return result;
      }

      function showFileStructure(data) {
        var signature = getFileSignature(data);
        var isHWP = signature.includes('D0 CF 11 E0');

        // Try to get CFB structure info
        var cfbInfo = '';
        try {
          if (typeof CFB !== 'undefined') {
            var cfb = CFB.read(data, { type: 'array' });
            if (cfb.FileIndex) {
              cfbInfo = '<div style="margin-top: 15px; padding: 15px; background: #fff3cd; border-left: 3px solid #ffc107;">';
              cfbInfo += '<p style="margin: 0 0 10px 0; color: #856404; font-size: 14px;"><strong>CFB ìŠ¤íŠ¸ë¦¼ ëª©ë¡:</strong></p>';
              cfbInfo += '<ul style="margin: 0; padding-left: 20px; color: #856404;">';
              for (var i = 0; i < Math.min(cfb.FileIndex.length, 10); i++) {
                var entry = cfb.FileIndex[i];
                if (entry.type !== 0) { // Not empty
                  cfbInfo += '<li>' + entry.name + ' (' + (entry.type === 2 ? 'File' : 'Directory') + ')</li>';
                }
              }
              if (cfb.FileIndex.length > 10) {
                cfbInfo += '<li>... and ' + (cfb.FileIndex.length - 10) + ' more</li>';
              }
              cfbInfo += '</ul></div>';
            }
          }
        } catch (e) {
          console.error('[HWP] Error getting CFB structure:', e);
        }

        return `
          <div style="background: #f8f9fa; padding: 20px; border-radius: 4px;">
            <h4 style="color: #0078d4; margin-top: 0;">íŒŒì¼ êµ¬ì¡° ì •ë³´</h4>
            <p style="color: #555;"><strong>íŒŒì¼ ì‹œê·¸ë‹ˆì²˜:</strong> ${signature}</p>
            <p style="color: #555;"><strong>íŒŒì¼ í˜•ì‹:</strong> ${isHWP ? 'HWP (OLE2 ë³µí•© ë¬¸ì„œ)' : 'ì•Œ ìˆ˜ ì—†ìŒ'}</p>
            <p style="color: #555;"><strong>ë°ì´í„° í¬ê¸°:</strong> ${data.length} bytes (${Math.round(data.length / 1024)} KB)</p>

            <div style="margin-top: 20px; padding: 15px; background: white; border: 1px solid #ddd;">
              <p style="margin: 0; color: #666; line-height: 1.6;">
                ì´ HWP íŒŒì¼ì€ ë³µí•© ë¬¸ì„œ í˜•ì‹ì…ë‹ˆë‹¤.
                PrvText ìŠ¤íŠ¸ë¦¼ì—ì„œ ë¯¸ë¦¬ë³´ê¸° í…ìŠ¤íŠ¸ë¥¼ ì¶”ì¶œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.
                ì™„ì „í•œ ë¬¸ì„œë¥¼ ë³´ë ¤ë©´ BodyText ì„¹ì…˜ íŒŒì‹±ì´ í•„ìš”í•©ë‹ˆë‹¤.
              </p>
            </div>

            ${cfbInfo}

            <div style="margin-top: 15px; padding: 15px; background: #e3f2fd; border-left: 3px solid #2196f3;">
              <p style="margin: 0; color: #1976d2; font-size: 14px;">
                <strong>ì›ì‹œ ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°:</strong>
              </p>
              <pre style="margin: 10px 0 0 0; padding: 10px; background: white; border: 1px solid #ddd; overflow-x: auto; font-size: 12px;">${getHexDump(data, 256)}</pre>
            </div>
          </div>
        `;
      }

      // Main Viewer constructor
      window.hwpjs = {
        Viewer: function(container, data) {
          console.log('[HWP] Simple HWP Viewer initialized');
          console.log('[HWP] Data size:', data ? data.length : 0);

          if (!data || data.length === 0) {
            container.innerHTML = '<p style="color: red;">No data provided</p>';
            return this;
          }

          try {
            // Extract both preview and full text
            var textData = extractTextWithDetails(data);

            container.innerHTML = `
            <div style="background: white; padding: 40px; max-width: 900px; margin: 0 auto; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
              <div style="background: #0078d4; color: white; padding: 15px; margin: -40px -40px 20px -40px;">
                <h2 style="margin: 0; font-size: 18px;">í•œê¸€ ë¬¸ì„œ (HWP)</h2>
              </div>
              <div style="background: #f8f9fa; padding: 20px; border-left: 4px solid #0078d4; margin-bottom: 20px;">
                <p style="margin: 0; color: #333;"><strong>íŒŒì¼ í¬ê¸°:</strong> ${Math.round(data.length / 1024)} KB</p>
                <p style="margin: 5px 0 0 0; color: #333;"><strong>ë°ì´í„°:</strong> ${data.length} bytes</p>
                ${textData.pageCount > 0 ? '<p style="margin: 5px 0 0 0; color: #333;"><strong>í˜ì´ì§€:</strong> ' + textData.pageCount + ' í˜ì´ì§€</p>' : ''}
              </div>
              ${formatDocumentContent(textData, data)}
              <div style="background: #fff3cd; padding: 15px; border-left: 4px solid #ffc107; margin-top: 20px;">
                <p style="margin: 0; color: #856404; font-size: 14px;">
                  <strong>ì°¸ê³ :</strong> ${textData.source === 'bodytext' ? 'BodyText ì„¹ì…˜ì—ì„œ ì „ì²´ ë¬¸ì„œë¥¼ ì¶”ì¶œí–ˆìŠµë‹ˆë‹¤.' : textData.source === 'prvtext' ? 'PrvTextì—ì„œ ë¯¸ë¦¬ë³´ê¸°(1-2í˜ì´ì§€)ë¥¼ ì¶”ì¶œí–ˆìŠµë‹ˆë‹¤.' : 'ê¸°ë³¸ í…ìŠ¤íŠ¸ ì¶”ì¶œ ë°©ì‹ì„ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.'}
                </p>
              </div>
            </div>
          `;
        } catch (error) {
          console.error('[HWP] Error parsing file:', error);
          container.innerHTML = `
            <div style="padding: 40px;">
              <h3 style="color: #d32f2f;">HWP íŒŒì¼ ë¶„ì„ ì˜¤ë¥˜</h3>
              <p style="color: #666;">ì˜¤ë¥˜: ${error.message}</p>
              <div style="background: #f5f5f5; padding: 20px; margin-top: 20px;">
                <p><strong>íŒŒì¼ ì •ë³´:</strong></p>
                <ul>
                  <li>í¬ê¸°: ${Math.round(data.length / 1024)} KB</li>
                  <li>ë°”ì´íŠ¸: ${data.length}</li>
                  <li>ì²« 4ë°”ì´íŠ¸: ${getFileSignature(data)}</li>
                </ul>
              </div>
            </div>
          `;
        }

        return this;
      }
    };

    console.log('[HWP] Simple HWP viewer loaded');
    })();

  </script>

  <!-- HWP.js fallback placeholder -->
  <script>
    // Fallback placeholder if CDN load fails
    if (typeof window.hwpjs === 'undefined') {
      window.hwpjs = {
        Viewer: function(container, data) {
          console.log('[HWP] Fallback Placeholder Viewer initialized');
          console.log('[HWP] Container:', container);
          console.log('[HWP] Data size:', data ? data.length : 0);

          // Create a placeholder UI with scrollable content
          container.innerHTML = `
          <div style="padding: 40px; background: white; border: 2px dashed #ccc; border-radius: 8px; text-align: center; min-height: 1200px;">
            <h2 style="color: #0078d4; margin-bottom: 20px;">HWP ë·°ì–´</h2>
            <div style="background: #f0f0f0; padding: 30px; border-radius: 6px; margin: 20px 0;">
              <p style="font-size: 16px; color: #333; margin: 10px 0;">
                <strong>íŒŒì¼ ì •ë³´:</strong>
              </p>
              <p style="color: #666; margin: 5px 0;">
                íŒŒì¼ í¬ê¸°: ${data ? Math.round(data.length / 1024) + ' KB' : 'ì•Œ ìˆ˜ ì—†ìŒ'}
              </p>
              <p style="color: #666; margin: 5px 0;">
                í˜•ì‹: HWP (í•œê¸€ ì›Œë“œí”„ë¡œì„¸ì„œ)
              </p>
            </div>
            <div style="background: #e8f4f8; padding: 20px; border-left: 4px solid #0078d4; margin: 20px 0; text-align: left;">
              <p style="margin: 5px 0; color: #333;"><strong>ì•ˆë‚´:</strong></p>
              <p style="margin: 5px 0; color: #555;">HWP íŒŒì¼ì´ ì„±ê³µì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.</p>
              <p style="margin: 5px 0; color: #555;">ì‹¤ì œ HWP ë¬¸ì„œ ë Œë”ë§ì„ ìœ„í•´ì„œëŠ” hwp.js ë¸Œë¼ìš°ì € ë²ˆë“¤ì´ í•„ìš”í•©ë‹ˆë‹¤.</p>
            </div>
            <div style="margin-top: 30px; padding: 20px; background: white; border: 1px solid #ddd; text-align: left;">
              <h3 style="color: #0078d4; margin-bottom: 15px;">êµ¬í˜„ëœ ê¸°ëŠ¥:</h3>
              <ul style="color: #555; line-height: 1.8; list-style-position: inside;">
                <li>âœ… HWP íŒŒì¼ ì—´ê¸° (íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒì)</li>
                <li>âœ… ê°€ìƒ íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ HWP íŒŒì¼ ë¡œë“œ</li>
                <li>âœ… í™•ëŒ€/ì¶•ì†Œ ê¸°ëŠ¥</li>
                <li>âœ… í˜ì´ì§€ íƒìƒ‰ ê¸°ëŠ¥</li>
                <li>âœ… ì¸ì‡„ ê¸°ëŠ¥</li>
                <li>âœ… ë“œë˜ê·¸ ì•¤ ë“œë¡­ ì§€ì›</li>
                <li>âœ… ìŠ¤í¬ë¡¤ ê¸°ëŠ¥</li>
                <li>â³ HWP ë¬¸ì„œ ë Œë”ë§ (hwp.js ë¸Œë¼ìš°ì € ë²ˆë“¤ í•„ìš”)</li>
              </ul>
            </div>
            <div style="margin-top: 30px; padding: 30px; background: #f9f9f9; border: 1px solid #ddd; text-align: left;">
              <h3 style="color: #0078d4; margin-bottom: 15px;">ë¬¸ì„œ ë‚´ìš© ë¯¸ë¦¬ë³´ê¸°</h3>
              <p style="color: #555; line-height: 1.8; margin: 10px 0;">
                ì´ê³³ì—ëŠ” ì‹¤ì œ HWP ë¬¸ì„œì˜ ë‚´ìš©ì´ í‘œì‹œë©ë‹ˆë‹¤.
              </p>
              <p style="color: #555; line-height: 1.8; margin: 10px 0;">
                hwp.js ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ í†µí•©ë˜ë©´ í•œê¸€ ì›Œë“œí”„ë¡œì„¸ì„œ ë¬¸ì„œì˜ í…ìŠ¤íŠ¸, ì´ë¯¸ì§€, í‘œ,
                ê·¸ë¦¬ê³  ë‹¤ì–‘í•œ ì„œì‹ì´ ì›ë³¸ ê·¸ëŒ€ë¡œ ë Œë”ë§ë©ë‹ˆë‹¤.
              </p>
              <div style="background: white; padding: 20px; margin: 20px 0; border-left: 3px solid #0078d4;">
                <h4 style="color: #333; margin: 10px 0;">ìŠ¤í¬ë¡¤ í…ŒìŠ¤íŠ¸ ì˜ì—­</h4>
                <p style="color: #666; line-height: 1.6;">
                  ì´ ì˜ì—­ì€ ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì„ í…ŒìŠ¤íŠ¸í•˜ê¸° ìœ„í•œ ê³µê°„ì…ë‹ˆë‹¤.
                  ì°½ì˜ í¬ê¸°ë¥¼ ì¡°ì ˆí•˜ê±°ë‚˜ í™•ëŒ€/ì¶•ì†Œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬
                  ìŠ¤í¬ë¡¤ë°”ê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </p>
                ${Array(10).fill(0).map((_, i) => `
                  <p style="color: #888; line-height: 1.6; margin: 10px 0;">
                    ${i + 1}. ìŠ¤í¬ë¡¤ í…ŒìŠ¤íŠ¸ ë¼ì¸ì…ë‹ˆë‹¤.
                    ì´ í…ìŠ¤íŠ¸ëŠ” ìŠ¤í¬ë¡¤ ê¸°ëŠ¥ì´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ê¸° ìœ„í•œ ê²ƒì…ë‹ˆë‹¤.
                    ì°½ì˜ ë†’ì´ë³´ë‹¤ ì»¨í…ì¸ ê°€ ê¸¸ ê²½ìš° ìŠ¤í¬ë¡¤ë°”ê°€ ë‚˜íƒ€ë‚˜ì•¼ í•©ë‹ˆë‹¤.
                  </p>
                `).join('')}
              </div>
            </div>
            <div style="margin-top: 30px; padding: 20px; background: #fff3cd; border-left: 4px solid #ffc107; text-align: left;">
              <h4 style="color: #856404; margin: 10px 0;">í–¥í›„ ê°œì„  ì‚¬í•­</h4>
              <ul style="color: #856404; line-height: 1.8;">
                <li>ì‹¤ì œ HWP ë¬¸ì„œ ë Œë”ë§</li>
                <li>í…ìŠ¤íŠ¸ ê²€ìƒ‰ ê¸°ëŠ¥</li>
                <li>ë¶ë§ˆí¬ ê¸°ëŠ¥</li>
                <li>ì£¼ì„ ì¶”ê°€ ê¸°ëŠ¥</li>
                <li>PDF ë³€í™˜ ê¸°ëŠ¥</li>
              </ul>
            </div>
          </div>
        `;

          return this;
        }
      };

      console.log('[HWP] Fallback placeholder initialized');
    }
  </script>

  ${preBootJs}

  <!-- Service Worker Registration for cache management -->
  <script>
    // Register Service Worker for cache busting
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function() {
        navigator.serviceWorker.register('${resourcePath}deskweb/sw.js?v=' + Date.now())
          .then(function(registration) {
            console.log('[App] ServiceWorker registered:', registration.scope);

            // Check for updates every 60 seconds
            setInterval(function() {
              registration.update();
            }, 60000);

            // Listen for updates
            registration.addEventListener('updatefound', function() {
              const newWorker = registration.installing;
              console.log('[App] ServiceWorker update found');

              newWorker.addEventListener('statechange', function() {
                if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                  console.log('[App] New ServiceWorker installed, reloading page...');

                  // Notify user and reload
                  if (confirm('A new version is available. Reload to update?')) {
                    newWorker.postMessage({ type: 'SKIP_WAITING' });
                    window.location.reload();
                  }
                }
              });
            });
          })
          .catch(function(error) {
            console.log('[App] ServiceWorker registration failed:', error);
          });

        // Handle controller change (new service worker activated)
        navigator.serviceWorker.addEventListener('controllerchange', function() {
          console.log('[App] ServiceWorker controller changed, reloading...');
          window.location.reload();
        });
      });
    }

    // Add timestamp to prevent cache
    (function() {
      var timestamp = new Date().getTime();
      console.log('[App] Loading with timestamp:', timestamp);

      // Store version info
      window.DESKWEB_VERSION = timestamp;
    })();
  </script>

  <script type="text/javascript" src="${appPath}index.js?v=${timestamp}"></script>

 </head>
<body>
</body>
</html>
